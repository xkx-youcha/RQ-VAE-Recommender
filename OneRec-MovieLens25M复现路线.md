# OneRec 与 RQ-VAE 项目结合及 MovieLens-25M 复现路线

## 1. OneRec 与 RQ-VAE 项目结合可能性分析

### 1.1 技术架构对比

| 特性 | RQ-VAE | OneRec |
|------|--------|--------|
| **核心思想** | 生成式检索，通过语义ID生成推荐 | 端到端序列推荐，直接建模用户行为序列 |
| **模型结构** | 两阶段：RQ-VAE编码 + Transformer解码 | 单阶段：大规模序列模型 |
| **输出形式** | 生成语义ID序列 | 直接输出推荐物品 |
| **优势** | 高效索引、可解释性强 | 端到端优化、信息完整 |

### 1.2 结合可能性分析

#### 1.2.1 直接结合方案
- **RQ-VAE作为特征编码器**：使用 RQ-VAE 将物品特征编码为语义ID，作为 OneRec 的输入特征
- **混合架构**：RQ-VAE 负责物品表示学习，OneRec 负责序列建模和推荐

#### 1.2.2 渐进式结合方案
- **阶段1**：使用 RQ-VAE 生成语义ID
- **阶段2**：基于语义ID序列训练 OneRec 模型

#### 1.2.3 并行对比方案（推荐）
- **独立实现**：分别实现 RQ-VAE 和 OneRec
- **效果对比**：在相同数据集上对比两种方法的性能

### 1.3 推荐实现方案

基于项目现状和复杂度考虑，推荐采用**并行对比方案**：
1. 保持现有 RQ-VAE 实现不变
2. 新增 OneRec 实现模块
3. 在 MovieLens-25M 上对比两种方法
4. 后续可考虑结合方案

## 2. MovieLens-25M 上 OneRec 复现路线

### 2.1 整体架构设计

```
OneRec 模型架构：
用户行为序列 → 物品嵌入层 → Transformer编码器 → 预测层 → 推荐结果
     ↓              ↓              ↓              ↓
   [item1, item2, item3, ...] → [emb1, emb2, emb3, ...] → [h1, h2, h3, ...] → [p1, p2, p3, ...]
```

### 2.2 核心组件设计

#### 2.2.1 序列建模
- **输入**：用户历史交互序列 `[item_1, item_2, ..., item_n]`
- **输出**：下一个物品的预测概率分布
- **模型**：Transformer-based 序列模型

#### 2.2.2 损失函数
- **主要损失**：交叉熵损失（预测下一个物品）
- **辅助损失**：序列重建损失（可选）
- **正则化**：Dropout、LayerNorm

#### 2.2.3 训练策略
- **负采样**：高效负采样策略
- **序列截断**：最大序列长度限制
- **批次构建**：动态批次大小

### 2.3 复现步骤规划

#### 阶段1：数据准备与预处理
1. **数据加载**：加载 MovieLens-25M 数据集
2. **序列构建**：构建用户行为序列
3. **特征工程**：物品特征处理（可选）
4. **数据分割**：训练/验证/测试集划分

#### 阶段2：模型实现
1. **物品嵌入层**：物品ID到嵌入向量的映射
2. **位置编码**：序列位置信息编码
3. **Transformer编码器**：多头注意力机制
4. **预测头**：输出层和损失计算

#### 阶段3：训练与优化
1. **训练循环**：批次训练实现
2. **评估指标**：NDCG、Recall、MRR等
3. **超参数调优**：学习率、批次大小等
4. **模型保存**：检查点保存和加载

#### 阶段4：推理与评估
1. **推理实现**：模型推理代码
2. **效果评估**：与基线方法对比
3. **消融实验**：组件重要性分析

### 2.4 技术细节

#### 2.4.1 模型参数
- **嵌入维度**：128-512
- **Transformer层数**：4-8层
- **注意力头数**：8-16
- **序列长度**：50-200
- **批次大小**：256-1024

#### 2.4.2 训练技巧
- **学习率调度**：Warmup + 衰减
- **梯度裁剪**：防止梯度爆炸
- **早停策略**：防止过拟合
- **混合精度**：加速训练

#### 2.4.3 评估指标
- **NDCG@K**：归一化折损累积增益
- **Recall@K**：召回率
- **MRR**：平均倒数排名
- **Hit Rate@K**：命中率

### 2.5 文件结构设计

```
experiments/
├── onerec/
│   ├── __init__.py
│   ├── data_processor.py      # 数据预处理
│   ├── model.py              # OneRec模型实现
│   ├── trainer.py            # 训练器
│   ├── evaluator.py          # 评估器
│   └── utils.py              # 工具函数
├── configs/
│   └── onerec_ml25m.gin      # OneRec配置文件
└── scripts/
    ├── train_onerec.py       # 训练脚本
    └── evaluate_onerec.py    # 评估脚本
```

### 2.6 预期效果

#### 2.6.1 性能指标
- **NDCG@10**：目标 > 0.15
- **Recall@10**：目标 > 0.20
- **MRR**：目标 > 0.10

#### 2.6.2 与基线对比
- **对比方法**：BPR、NCF、SASRec、BERT4Rec
- **优势预期**：端到端优化，信息完整
- **劣势预期**：计算复杂度较高

### 2.7 实施计划

#### 第1周：数据准备
- [ ] 实现数据加载和预处理
- [ ] 构建用户行为序列
- [ ] 实现数据分割策略

#### 第2周：模型实现
- [ ] 实现物品嵌入层
- [ ] 实现Transformer编码器
- [ ] 实现预测头和损失函数

#### 第3周：训练优化
- [ ] 实现训练循环
- [ ] 添加评估指标
- [ ] 超参数调优

#### 第4周：评估对比
- [ ] 实现推理代码
- [ ] 与基线方法对比
- [ ] 消融实验分析

## 3. 关键挑战与解决方案

### 3.1 计算资源挑战
- **问题**：大规模序列模型训练需要大量GPU资源
- **解决**：梯度累积、混合精度训练、分布式训练

### 3.2 负采样策略
- **问题**：大规模物品库的负采样效率
- **解决**：高效负采样算法、硬负样本挖掘

### 3.3 序列长度限制
- **问题**：长序列的注意力计算复杂度
- **解决**：序列截断、滑动窗口、稀疏注意力

### 3.4 冷启动问题
- **问题**：新用户/新物品的推荐
- **解决**：元学习、迁移学习、特征工程

## 4. 后续扩展方向

### 4.1 多模态融合
- 结合电影海报、文本描述等特征
- 多模态Transformer架构

### 4.2 多目标优化
- 同时优化点击率、停留时长、评分等
- 多任务学习框架

### 4.3 实时推荐
- 在线学习和增量更新
- 流式数据处理

### 4.4 可解释性
- 注意力权重可视化
- 推荐理由生成

---

**注意**：本文档主要记录思路和执行过程，具体代码实现将在后续步骤中分别提供。 